# This function has been generated by Claude AI
function Anonymize-Object {
    <#
    .SYNOPSIS
    Anonymize sensitive data in an object while preserving structure.

    .DESCRIPTION
    Recursively traverses an object and replaces string values with anonymized versions.
    GUIDs are replaced with random GUIDs, UPNs/emails are replaced with random but valid-looking UPNs, and other strings are replaced with random strings of the same length.
    The function maintains a mapping of original to anonymized values to ensure consistency across multiple calls within the same session.

    .PARAMETER InputObject
    The object to anonymize. Can be a scalar value, hashtable, PSCustomObject, or collection.

    .PARAMETER Properties
    Optional list of property names to anonymize. If empty or not provided, all string properties will be anonymized.

    .PARAMETER ValueMap
    Optional hashtable to maintain mapping of original to anonymized values for consistency across multiple calls. If not provided, a new map will be created for the session.

    .EXAMPLE
    Anonymize ALL properties (default):
    $anonymized = Anonymize-Object -InputObject $yourObject
    
    Anonymize ONLY specific properties (others remain unchanged):
    $anonymized = Anonymize-Object -InputObject $users -Properties @("id", "userPrincipalName", "displayName", "mail")
    
    UPNs/emails keep their format:
    "john.doe@contoso.com" â†’ "xkqmzpwl@abcdefg.com"

    Maintain consistency across multiple calls by passing a shared ValueMap:
    $map = @{}
    $anon1 = Anonymize-Object -InputObject $obj1 -ValueMap $map
    $anon2 = Anonymize-Object -InputObject $obj2 -ValueMap $map  # Same values map to same fake values

    .OUTPUTS
    An anonymized version of the input object with the same structure but sensitive values replaced.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [object]$InputObject,

        [Parameter(Mandatory = $false)]
        [string[]]$Properties = @(),  # Properties to anonymize (empty = anonymize all)

        [Parameter(Mandatory = $false)]
        [hashtable]$ValueMap = @{}
    )

    # Regex patterns
    [regex]$guidRegex = "(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$"
    [regex]$upnRegex = "^[^@]+@[^@]+\.[a-z]{2,}$"

    # Helper: Generate random GUID
    function New-RandomGuid {
        return [guid]::NewGuid().ToString()
    }

    # Helper: Generate random string of similar length
    function New-RandomString {
        param([int]$Length)
        if ($Length -lt 1) { $Length = 8 }
        if ($Length -gt 200) { $Length = 200 }
        $chars = "abcdefghijklmnopqrstuvwxyz"
        $charArray = $chars.ToCharArray()
        $result = @()
        for ($i = 0; $i -lt $Length; $i++) {
            $result += $charArray | Get-Random
        }
        return -join $result
    }

    # Helper: Anonymize UPN/email while preserving format
    function New-AnonymizedUpn {
        param([string]$Upn)
        $parts = $Upn -split '@'
        $localPart = $parts[0]
        $domainPart = $parts[1]
        
        # Anonymize local part
        $anonLocal = New-RandomString -Length $localPart.Length
        
        # Anonymize domain (keep TLD structure)
        $domainParts = $domainPart -split '\.'
        $anonDomainParts = @()
        for ($i = 0; $i -lt $domainParts.Count; $i++) {
            if ($i -eq ($domainParts.Count - 1)) {
                # Keep TLD as-is (com, org, net, etc.)
                $anonDomainParts += $domainParts[$i]
            } else {
                $anonDomainParts += New-RandomString -Length $domainParts[$i].Length
            }
        }
        
        return "$anonLocal@$($anonDomainParts -join '.')"
    }

    # Helper: Anonymize a single scalar value with consistency
    function Get-AnonymizedValue {
        param(
            [object]$Value,
            [hashtable]$Map
        )
        
        if ($null -eq $Value) { return $null }
        
        $valueStr = [string]$Value

        # Return cached value if already mapped
        if ($Map.ContainsKey($valueStr)) {
            return $Map[$valueStr]
        }

        $anonymized = $null

        # Check if it's a GUID
        if ($valueStr -match $guidRegex) {
            $anonymized = New-RandomGuid
        }
        # Check if it's a UPN/email
        elseif ($valueStr -match $upnRegex) {
            $anonymized = New-AnonymizedUpn -Upn $valueStr
        }
        # Check if it's a number (preserve as-is)
        elseif ($Value -is [int] -or $Value -is [long] -or $Value -is [double] -or $Value -is [decimal]) {
            $anonymized = $Value
        }
        # Check if it's a boolean
        elseif ($Value -is [bool]) {
            $anonymized = $Value
        }
        # Check if it's a date
        elseif ($Value -is [datetime]) {
            $anonymized = $Value
        }
        # Otherwise treat as string
        else {
            $len = $valueStr.Length
            if ($len -gt 0) {
                $anonymized = New-RandomString -Length $len
            } else {
                $anonymized = ""
            }
        }

        # Cache the mapping for consistency
        $Map[$valueStr] = $anonymized
        return $anonymized
    }

    # Internal recursive function
    function Anonymize-Internal {
        param(
            [object]$Obj,
            [string[]]$PropsToAnon,
            [hashtable]$Map,
            [string]$CurrentProperty = ""
        )

        # Handle null
        if ($null -eq $Obj) { return $null }

        # Handle arrays/collections
        if ($Obj.GetType().IsArray -or $Obj -is [System.Collections.ICollection]) {
            $result = @()
            foreach ($item in $Obj) {
                $result += Anonymize-Internal -Obj $item -PropsToAnon $PropsToAnon -Map $Map
            }
            return $result
        }

        # Handle hashtables/dictionaries
        if ($Obj -is [hashtable] -or $Obj.GetType().Name -like "*Dictionary*") {
            $result = @{}
            foreach ($key in $Obj.Keys) {
                $value = $Obj[$key]
                
                # Check if we should anonymize this key
                $shouldAnonymize = ($PropsToAnon.Count -eq 0) -or ($PropsToAnon -contains $key)

                if ($null -ne $value -and 
                    ($value -is [hashtable] -or 
                     $value.GetType().Name -like "*Dictionary*" -or
                     $value.GetType().Name -eq "PSCustomObject" -or
                     $value.GetType().IsArray -or
                     $value -is [System.Collections.ICollection])) {
                    $result[$key] = Anonymize-Internal -Obj $value -PropsToAnon $PropsToAnon -Map $Map -CurrentProperty $key
                }
                elseif ($shouldAnonymize) {
                    $result[$key] = Get-AnonymizedValue -Value $value -Map $Map
                }
                else {
                    $result[$key] = $value
                }
            }
            return $result
        }

        # Handle PSCustomObject
        if ($Obj.GetType().Name -eq "PSCustomObject") {
            $result = New-Object PSObject
            foreach ($property in $Obj.PSObject.Properties) {
                $propName = $property.Name
                $value = $property.Value

                # Check if we should anonymize this property
                $shouldAnonymize = ($PropsToAnon.Count -eq 0) -or ($PropsToAnon -contains $propName)

                if ($null -ne $value -and 
                    ($value -is [hashtable] -or 
                     $value.GetType().Name -like "*Dictionary*" -or
                     $value.GetType().Name -eq "PSCustomObject" -or
                     $value.GetType().IsArray -or
                     $value -is [System.Collections.ICollection])) {
                    $result | Add-Member -MemberType NoteProperty -Name $propName -Value (Anonymize-Internal -Obj $value -PropsToAnon $PropsToAnon -Map $Map -CurrentProperty $propName)
                }
                elseif ($shouldAnonymize) {
                    $result | Add-Member -MemberType NoteProperty -Name $propName -Value (Get-AnonymizedValue -Value $value -Map $Map)
                }
                else {
                    $result | Add-Member -MemberType NoteProperty -Name $propName -Value $value
                }
            }
            return $result
        }

        # For scalar values at the root level
        return Get-AnonymizedValue -Value $Obj -Map $Map
    }

    # Execute with the provided or new value map
    return Anonymize-Internal -Obj $InputObject -PropsToAnon $Properties -Map $ValueMap
}

